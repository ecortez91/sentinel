use chrono::{DateTime, Local};
use std::fmt;

/// Severity levels for alerts - drives color coding and sort priority.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum AlertSeverity {
    Info,
    Warning,
    Critical,
    Danger,
}

impl fmt::Display for AlertSeverity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AlertSeverity::Info => write!(f, "INFO"),
            AlertSeverity::Warning => write!(f, "WARN"),
            AlertSeverity::Critical => write!(f, "CRIT"),
            AlertSeverity::Danger => write!(f, "DANGER"),
        }
    }
}

/// Category of the alert for filtering and grouping.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum AlertCategory {
    HighCpu,
    HighMemory,
    HighDiskIo,
    Zombie,
    Suspicious,
    SystemOverload,
    MemoryLeak,
    SecurityThreat,
    ThermalWarning,
    ThermalCritical,
    ThermalEmergency,
}

impl fmt::Display for AlertCategory {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AlertCategory::HighCpu => write!(f, "CPU"),
            AlertCategory::HighMemory => write!(f, "MEM"),
            AlertCategory::HighDiskIo => write!(f, "DISK"),
            AlertCategory::Zombie => write!(f, "ZOMBIE"),
            AlertCategory::Suspicious => write!(f, "SUSPECT"),
            AlertCategory::SystemOverload => write!(f, "OVERLOAD"),
            AlertCategory::MemoryLeak => write!(f, "LEAK"),
            AlertCategory::SecurityThreat => write!(f, "SECURITY"),
            AlertCategory::ThermalWarning => write!(f, "THERMAL"),
            AlertCategory::ThermalCritical => write!(f, "THERMAL!"),
            AlertCategory::ThermalEmergency => write!(f, "THERMAL!!"),
        }
    }
}

/// A single alert event generated by the detection engine.
#[derive(Debug, Clone)]
#[allow(dead_code)]
pub struct Alert {
    pub severity: AlertSeverity,
    pub category: AlertCategory,
    pub process_name: String,
    pub pid: u32,
    pub message: String,
    pub timestamp: DateTime<Local>,
    pub value: f64,
    pub threshold: f64,
}

impl Alert {
    pub fn new(
        severity: AlertSeverity,
        category: AlertCategory,
        process_name: &str,
        pid: u32,
        message: String,
        value: f64,
        threshold: f64,
    ) -> Self {
        Self {
            severity,
            category,
            process_name: process_name.to_string(),
            pid,
            message,
            timestamp: Local::now(),
            value,
            threshold,
        }
    }

    pub fn age_display(&self) -> String {
        let elapsed = Local::now()
            .signed_duration_since(self.timestamp)
            .num_seconds();
        if elapsed < 60 {
            format!("{}s ago", elapsed)
        } else if elapsed < 3600 {
            format!("{}m ago", elapsed / 60)
        } else {
            format!("{}h ago", elapsed / 3600)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // ── AlertSeverity Display ─────────────────────────────────────

    #[test]
    fn severity_display() {
        assert_eq!(AlertSeverity::Info.to_string(), "INFO");
        assert_eq!(AlertSeverity::Warning.to_string(), "WARN");
        assert_eq!(AlertSeverity::Critical.to_string(), "CRIT");
        assert_eq!(AlertSeverity::Danger.to_string(), "DANGER");
    }

    #[test]
    fn severity_ordering() {
        // Info < Warning < Critical < Danger
        assert!(AlertSeverity::Info < AlertSeverity::Warning);
        assert!(AlertSeverity::Warning < AlertSeverity::Critical);
        assert!(AlertSeverity::Critical < AlertSeverity::Danger);
    }

    // ── AlertCategory Display ─────────────────────────────────────

    #[test]
    fn category_display() {
        assert_eq!(AlertCategory::HighCpu.to_string(), "CPU");
        assert_eq!(AlertCategory::HighMemory.to_string(), "MEM");
        assert_eq!(AlertCategory::HighDiskIo.to_string(), "DISK");
        assert_eq!(AlertCategory::Zombie.to_string(), "ZOMBIE");
        assert_eq!(AlertCategory::Suspicious.to_string(), "SUSPECT");
        assert_eq!(AlertCategory::SystemOverload.to_string(), "OVERLOAD");
        assert_eq!(AlertCategory::MemoryLeak.to_string(), "LEAK");
        assert_eq!(AlertCategory::SecurityThreat.to_string(), "SECURITY");
        assert_eq!(AlertCategory::ThermalWarning.to_string(), "THERMAL");
        assert_eq!(AlertCategory::ThermalCritical.to_string(), "THERMAL!");
        assert_eq!(AlertCategory::ThermalEmergency.to_string(), "THERMAL!!");
    }

    // ── Alert::new ────────────────────────────────────────────────

    #[test]
    fn alert_new_fields() {
        let alert = Alert::new(
            AlertSeverity::Warning,
            AlertCategory::HighCpu,
            "firefox",
            1234,
            "CPU usage high".to_string(),
            85.5,
            50.0,
        );
        assert_eq!(alert.severity, AlertSeverity::Warning);
        assert_eq!(alert.category, AlertCategory::HighCpu);
        assert_eq!(alert.process_name, "firefox");
        assert_eq!(alert.pid, 1234);
        assert_eq!(alert.message, "CPU usage high");
        assert!((alert.value - 85.5).abs() < f64::EPSILON);
        assert!((alert.threshold - 50.0).abs() < f64::EPSILON);
    }

    #[test]
    fn alert_timestamp_is_recent() {
        let before = Local::now();
        let alert = Alert::new(
            AlertSeverity::Info,
            AlertCategory::Zombie,
            "test",
            1,
            "msg".to_string(),
            0.0,
            0.0,
        );
        let after = Local::now();
        assert!(alert.timestamp >= before);
        assert!(alert.timestamp <= after);
    }

    // ── Alert::age_display ────────────────────────────────────────

    #[test]
    fn age_display_just_created() {
        let alert = Alert::new(
            AlertSeverity::Info,
            AlertCategory::HighCpu,
            "test",
            1,
            "msg".to_string(),
            0.0,
            0.0,
        );
        let display = alert.age_display();
        // Should be "0s ago" or "1s ago" depending on timing
        assert!(
            display.ends_with("s ago"),
            "Expected seconds, got: {}",
            display
        );
    }
}
